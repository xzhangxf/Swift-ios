Swift Language 3: Structs and classes
October 1, 2025 5:24 PM

# Structs

## What are structs?

*Classes and structures are general-purpose, flexible constructs that become the building blocks of your program’s code. You define properties and methods to add functionality to your classes and structures by using exactly the same syntax as for constants, variables, and functions.~* [The official Apple Developer documentation](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html)

- Think of structs as “chonky types” you can define. `Int`, `Bool`, `String`, `Double` not enough for you? Need to group them together to make a new type? You can, with structs! (And classes.)
- Let’s consider cars — say you want to make a new type, to collect information about a car.

## Properties

- What variables might you use to describe *how a car looks and works*?
    - `colour: String`
    - `numWheels: Int`
    - `isAuto: Bool`
- These variables are its *properties*, which store information about the car.

## Methods

- What can a car *do*?
    - `func turn(to direction:String)`
    - `func accelerate(by axn: Double)`
    - `func honk(loudness: Int)`
    - `func stillGotFuel() -> Bool`
- These functions are its *methods*.

## Creating our Car struct

We create a simple `Car` struct using the keyword `struct`, then add its properties and methods within the struct. 

```swift
struct Car {
    var colour: String
    var make: String
    var model: String
    var topSpeed: Int
    var maxFuel: Double
    var fuelLeft: Double
    
    func honk() {
        print("Hjönk") // Goose horn?
    }
    
    func stillGotFuel() -> Bool {
        if fuelLeft >= 1.0 {
            return true
        } else {
            return false
        }
    } // this could be one line....
    
}
```

## Instantiating the Car

Note how, in the above case, we don’t have a Car. We have a *blueprint of a Car.* To actually make the Car, we have to instantiate it: 

```swift
var car = Car(colour:"red", make:"Toyota", model:"Corolla", topSpeed:200, maxFuel:50.0, fuelLeft:40.0)
var otherCar = Car(colour:"blue", make:"BYD", model:"Seal", topSpeed:180, maxFuel:30.0, fuelLeft:30.0)
// now we have two variables, each of type Car
```

## Default property values

When you give a property a value in the struct definition, you don’t have to set it when you instantiate the property (though you can, if you want to).

```swift
struct Cat {
    var name: String
    var breed: String
    
    var age: Int
    var willBiteYou = true // default value
}

// My cat bites. No need to set willBiteYou!
var myCat = Cat(name: "Pommy", breed: "Domestic Shorthair", age: 15)

// Presumably this one doesn’t. Booooring.
var fictionalCat = Cat(name: "Garfield", breed: "Persian Tabby", age: 47, willBiteYou: false)
```

## Exercise 1.1: Add a method

- Add a new **describe** method, that tells you about the instance in question, using its own properties.
- This will involve some string interpolation!

```swift
var car = Car(colour:"red", make:"Toyota", model:"Corolla", topSpeed:200, maxFuel:50.0, fuelLeft:40.0)

car.describe()

// should print out:
// This car is a red Toyota Corolla with a top speed of
// 200 km/h.
```

## Exercise 1.2: Two Cars

- Make 2 Car instances, `car1` and `car2`, with your favourite makes and models.
- Write a **function** (*not* a method in Car!) to compare their top speeds.
- To test this `compareCar` function, you might write something like the below:

```swift
var car = Car(colour:"red", make:"Toyota", model:"Corolla", topSpeed:200, maxFuel:50.0, fuelLeft:40.0)
var car2 = Car(colour:”blue", make:"Mitsubishi", model:"Lancer", topSpeed:250, maxFuel:60, fuelLeft:20.0)

compareCars(car, car2)

// should print out:
// The Mitsubishi Lancer can go faster than the Toyota Corolla
```

## Exercise 1.3: Make your own

- Design your own struct for a pet dog or cat
- What properties would you need?
- What methods would be useful?
- Create an instance of it and call a method.
- Get creative!

```swift
cat.hasPomeloOnHead = true
cat.isAnnoyed = true

// Sorry cat
```

![CleanShot 2025-10-01 at 15.34.58@2x.png](attachment:1caec6ba-a705-42b4-8016-adfad5c5cde9:CleanShot_2025-10-01_at_15.34.582x.png)

# Classes

## Classes vs. Structs

They’re *very* similar! Differences: 

- Classes require explicit initialisers.
- Classes pass by reference.
- Structs can’t inherit.
- Structs are smaller and faster.

(Randomly, for the last two, just think of structs as pets. They’re smaller, maybe faster, and can’t inherit.)

## Classes need initialisers

- When we made structs (e.g. `struct Car`), Swift auto-generated the *initialiser* for us (e.g. `Car(make:, model:)`).
    - When we create a struct with default values, Swift auto-generated multiple initialisers for us!
- An initialiser is a function that runs in order to create your class or struct.
    - The initialiser accepts parameters, which it stores to create your class or struct.
    - Other languages may call this a *constructor*.
- Within your initialiser, you must set every property that does not already have a value
    - This means, if you declare your variable like this, you do not need to set its value in your initialiser: `var willBite = true`
    - However, you *will* need to set an initialiser for this: `var name: String`
- Think of your initialiser like running some code to set up your instance.
    - Structs can also have initialisers!
- This `Cat` class won’t work without the highlighted lines labelled with `init` — that’s its *initialiser*.

```swift
class Cat {
    var name: String
    var breed: String 
    
    var age: Int 
    var willBiteYou = true // default value
    
    init(name: String, breed: String, age: Int) {
        self.name = name
        self.breed = breed
        self.age = age
    }
}
```

- *What about our ViewControllers?*, you ask. Those inherited from `UIViewController`, which provided an `init` method.
- *What is `self`?* This has to do with *variable scope*.
    - In this case, the code is found within the initialiser, which takes in a `name: String` as a parameter. This means the name variable referenced here is going to refer to the incoming parameter.
    - However, every property needs a value. Therefore, you need to set the value of the *actual* `name` in the class. In order to do this, you use `self.name` to refer to the `name` variable owned by the class.
- Overloading
    - Let's say you want to create another initialiser for your class — you can do that, as long as it takes in different parameters.
    - This is called overloading. It lets you create functions and initialisers with different implementations.
        - We saw this before, in Swift Language 1, when we defined two functions with the same name, using argument labels for one of them.
    - See: https://en.wikipedia.org/wiki/Function_overloading
    - Here’s another initialiser:

```swift
class Cat {
    var name: String
    var breed: String 
    
    var age: Int 
    var willBiteYou = true // default value
    
    init(name: String, breed: String, age: Int) {
        self.name = name
        self.breed = breed
        self.age = age
    }
    
    init() {
        // sorry for the awful cat names
        let catNames = ["Apple", "Banana", "Cherry", "Durian"]
        name = catNames[Int.random(in: 0..<catNames.count)]
        breed = "Random Cat"
        age = 0
        
        // Notice how you don't need to use self.name here, 
        // because this time, it's very clear you can only be referring 
        // to the name from the class.
    }
}
```

## Pass by reference vs. pass by value

- Structs pass by value
    - When you assign a struct instance to another variable, or pass it as an argument, you make a copy of that struct (or rather, its values) that doesn’t affect the original.

```swift
struct Rect {
    var width: Double 
    var height: Double
}

var myRectangle = Rect(width: 10.0, height: 15.0)
var copyRectangle = myRectangle
myRectangle.width = 99
print(copyRectangle.width) // still 10.0
```

- Classes pass by reference
    - If you change an instance of it, everything else “pointing to it” (when you do assignment, or passing it as an argument to a function) also sees the change.

```swift
class Rect {
    var width: Double 
    var height: Double
    init(width: Double, height: Double) {
        self.width = width 
        self.height = height
    }
}

let myRectangle = Rect(width: 10.0, height: 15.0)
let copyRectangle = myRectangle
myRectangle.width = 99
print(copyRectangle.width) // now 99.0!
```

- Passing by reference, explained with an example:

```swift
let myRectangle = Rect(width: 10.0, height: 15.0)
let copyRectangle = myRectangle
myRectangle.width = 99
print(copyRectangle.width) // now 99.0!
```

- We only have one `Rect` instance, and when we assign `copyRectangle` to `myRectangle`, we’re just asking the latter to *refer to* what the former is pointing to.
- This is what it means by *pass by reference*. You aren't actually initialising a new instance of the class every time you pass it around!
- One more thing — you may have noticed `myRectangle` and `copyRectangle` are declared as constants. But we're able to change their width property!
    - As these two are just references, they aren't actually changed unless you actually initialise a brand new `Rect`.
- Summary
    - Structs are value types. They actually *contain* the value
    - Classes are reference types. They just say *“Hey, I’m pointing to this value over here!”*
    - Read this blog post to learn more: [*https://developer.apple.com/swift/blog/?id=10*](https://developer.apple.com/swift/blog/?id=10)

## Exercise 2: Cat shelter

- Using the `class` and `struct` below, create a new `Cat` variable `cat1`, aged 5.
- Create a new `Shelter`, `shelter1`, taking in parameter `cat1`.
- Create another `Shelter`, `shelter2`, and set `shelter2 = shelter1`.
- Set `shelter2.cat.age` to be 1, and guess: What is the value of `shelter1.cat.age`? Why?

//Exercise 1.1

struct Car {
    let colour: String
    let make: String
    let model: String
    let topSpeed: Int
    let maxFuel: Double
    let fuelLeft: Double
    
    func describe(){
        print("This car is a \(colour) \(make) \(model) with a top speed of\n\(topSpeed) km/h.")
    }
}

var car = Car(colour:"red", make:"Toyota", model:"Corolla", topSpeed:200, maxFuel:50.0, fuelLeft:40.0)
car.describe()

// should print out:
// This car is a red Toyota Corolla with a top speed of
// 200 km/h.


//Exercise 1.2
var car = Car(colour:"red", make:"Toyota", model:"Corolla", topSpeed:200, maxFuel:50.0, fuelLeft:40.0)
var car2 = Car(colour:"blue", make:"Mitsubishi", model:"Lancer", topSpeed:250, maxFuel:60, fuelLeft:20.0)

func compareCars(carone: Car, cartwo: Car) {
    if carone.topSpeed > cartwo.topSpeed {
        print("The \(carone.make) \(carone.model) can go faster than the \(cartwo.make) \(cartwo.model)")
    } else if cartwo.topSpeed > carone.topSpeed {
        print("The \(cartwo.make) \(cartwo.model) can go faster than the \(carone.make) \(carone.model)")
    } else {
        print("The \(carone.make) \(carone.model) and the \(cartwo.make) \(cartwo.model) have the same top speed.")
    }
}
compareCars(carone: car, cartwo: car2)

// should print out:
// The Mitsubishi Lancer can go faster than the Toyota Corolla


//Exercise 1.3
struct Cat{
    let name : String
    let age : Int
    let sleeping : Bool
    let bite : Bool
    
    func describe(){
        if bite {
            print("The cat name is \(name) age \(age) and it wil bite you, becareful when you touch it")
        } else{
            print("The cat name is \(name) age \(age) and it does not bite dont worry")
        }
//        
//        print("The cat name is \(name) age \(age) and \(bite) it wil bite you, it is \(sleeping) sleeping better dont touch it")
    }
    
    func wakeUp(){
        if sleeping {
            print("\(name) shifts slowly and opens one eye. The nap is over.")
        } else{
            print("\(name) is already awake and does not appreciate being distur")
        }
    }
}

var mycar = Cat(name: "Milo", age: 2, sleeping: true, bite: true)

mycar.describe()
mycar.wakeUp()


// type in your Swift code here
// Exercise 2
struct Kitty {
    var age: Int
}

class Shelter {
    var kitty: Kitty
    init(kitty: Kitty) {
        self.kitty = kitty
    }
}

var kitty1 = Kitty(age: 5)
var shelter1 = Shelter(kitty: kitty1)
var shelter2 = shelter1

shelter2.kitty.age = 1
// shelter 1 also changes - classes pass by reference!

print(shelter1.kitty.age)